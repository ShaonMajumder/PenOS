# Commit 1 - int 0x80 syscall dispatcher
**Branch:** feature/syscall-int80  \
**Commit:** "Add syscall dispatcher and handlers"  \
**Summary:** Introduced an `int 0x80` pathway with a minimal syscall table (write, ticks), registered a new IDT gate, and wired the timer ISR to avoid spurious EOIs.

Problem
: Tasks had no structured ABI to request kernel services; software interrupts defaulted to exceptions, and there was no dispatcher or syscall table.

Solution
: Added an `isr128` stub + IDT gate, registered a syscall handler that decodes numbers from EAX (args in EBX/ECX/EDX), and routed two syscalls: console write and `timer_ticks`. The dispatcher writes return values back into EAX so callers can read them immediately.

Architecture
```
user/kernel thread -> int 0x80 -> isr128 stub -> isr_dispatch
                                 -> syscall_handler(frame)
                                      eax=sysno, ebx..args
                                      frame->eax=return
```

Data structures
- `syscall_table[]`: array of function pointers taking `interrupt_frame_t *`.
- Existing interrupt frame reused as ABI container; no extra stack juggling required.

Tradeoffs
- Gate runs at DPL0 because no user-mode threads exist yet; once ring-3 tasks arrive we can raise the DPL.
- Only two syscalls exist; future features can extend the table and add validation.

Interactions
- Interrupt controller only receives EOIs for hardware IRQs (32?47) now, preventing bogus acknowledgements on software interrupts.
- Kernel init now calls `syscall_init` before bringing the scheduler online.

Scientific difficulty
: Ensuring the dispatcher played nicely with the existing ISR flow without corrupting registers (or double-sending EOIs) required careful review of the IDT + PIC handling sequence.

What to learn
: You can piggyback on your interrupt frame + dispatcher to build a syscall ABI quickly; start small (write/ticks) and evolve as new subsystems need service entry points.
