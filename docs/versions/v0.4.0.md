# PenOS v0.4.0

Summary
- Kernel now runs preemptive round-robin threads on dedicated stacks, driven by the PIT tick handler.

Architecture changes
- Timer ISR saves the running task's `interrupt_frame_t`, chooses the next runnable thread, and writes its context into the ISR frame before `iret`.
- Scheduler seeds demo counter/spinner tasks and allocates stacks from the higher-half heap.

Files touched
- `include/sched/sched.h`
- `src/sched/sched.c`
- `src/arch/x86/timer.c`
- `docs/architecture.md`
- `docs/commits/feature-scheduler/1_preemptive_rr.md`
- `CHANGELOG.md`, `VERSION`, `docs/versions/v0.4.0.md`

Lessons learned
- Leveraging the interrupt frame makes context switching possible without extra assembly glue.
- Dedicated stacks per task are essential once preemption is enabled; memory services (heap) must exist first.

Next steps
- Reclaim finished tasks and expose APIs for user-created threads.
- Hook syscalls/userspace so that round-robin extends beyond kernel demos.
