# PenOS v0.8.0

Summary
- Multiboot now stays in the 1024x768x32 framebuffer that GRUB hands us, draws a gradient PenOS splash/logo, and projects the shell into a tinted overlay so text-mode workflows keep working while the GUI groundwork lands.
- Shell grew a `shutdown` command wired to a tiny power-management helper so QEMU/VirtualBox/Bochs guests can power off cleanly without reaching for monitor controls.

Architecture changes
- `src/ui/framebuffer.c` consumes the Multiboot framebuffer fields, validates we are in a 32-bit direct-color mode, and exposes primitives (`framebuffer_draw_pixel/rect/text/blit_sprite`) plus a console-overlay helper that maps rows/columns into framebuffer coordinates. `framebuffer_render_splash` uses these primitives to draw the branded splash and reserve space for the console panel.
- `src/ui/console.c` now mirrors the VGA text buffer into a shadow array and, when the framebuffer is active, redraws each cell through the overlay so scrolling/clearing/backspace all update both outputs.
- `kernel_main` configures the framebuffer surface before `console_init` so the console can choose the right backend; the Makefile now injects `-DPENOS_VERSION="<VERSION>"` so the splash/logo can print the runtime version string.
- `src/sys/power.c` implements a minimal set of port writes that trigger ACPI shutdown on the major emulators/hypervisors; the shell dispatch simply calls it.

Files touched
- `include/ui/framebuffer.h`, `src/ui/framebuffer.c` (new)
- `src/kernel.c`, `src/ui/console.c`, `src/shell/shell.c`, `Makefile`, `include/sys/power.h`, `src/sys/power.c`
- Docs (`README.md`, `docs/architecture.md`, `CHANGELOG.md`, `docs/versions/v0.8.0.md`, `docs/commits/feature-framebuffer/1_framebuffer-console.md`)

Lessons learned
- Keeping the VGA text routines and mirroring them into the framebuffer overlay avoided a huge rewrite of the shell path while still unblocking graphics experiments.
- Passing the build version as a compiler define makes it trivial for UI layers (console, splash, future about boxes) to display release info without parsing files at runtime.

Next steps
- Add dedicated drawing demos (rect animations, font preview, mouse cursor) that exercise the framebuffer primitives.
- Hook the mouse driver into a basic cursor renderer so GUI prototyping can start immediately.
