# PenOS v0.5.0

Summary
- Introduced an `int 0x80` syscall pathway providing console write and tick-count services, laying groundwork for future user tasks.

Architecture changes
- Added an IDT gate/stub for vector 128 and a syscall dispatcher that reads EAX for the syscall number and EBX/ECX/EDX for arguments.
- Updated interrupt controller handling so EOIs are only sent for hardware IRQs.
- Kernel init now calls `syscall_init` after the heap and before spinning up the scheduler.

Files touched
- `include/sys/syscall.h`
- `src/sys/syscall.c`
- `src/arch/x86/isr_stubs.S`
- `src/arch/x86/interrupts.c`
- `src/arch/x86/timer.c`
- `src/kernel.c`
- Docs (`README.md`, `docs/architecture.md`, `docs/commits/feature-syscall/1_int80.md`, `CHANGELOG.md`, `VERSION`, `docs/versions/v0.5.0.md`)

Lessons learned
- Software interrupts need their own IDT gates and should never send PIC EOIs.
- Establishing the syscall ABI early (register usage, return values) keeps future user-mode and service APIs consistent.

Next steps
- Broaden the syscall table (memory allocation, IPC, scheduler hooks) and eventually raise the gate's DPL for ring-3 callers.
- Pair syscalls with user-mode tasks and a more complete shell command (`syscall` demo) to validate the ABI.
